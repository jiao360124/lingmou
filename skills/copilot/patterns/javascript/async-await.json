[
  {
    "patternId": "js.async.try.catch",
    "category": "async-await",
    "name": "Try-Catch错误处理",
    "description": "使用async/await和try-catch捕获异步错误",
    "keywords": ["async", "await", "try", "catch", "error"],
    "template": "async function {name}() { try { const result = await {promise}; } catch (error) { {handleError} } }",
    "example": "async function fetchData() { try { const data = await fetch(url); } catch (error) { console.error(error); } }",
    "score": 0.98,
    "language": "javascript",
    "popularity": 0.97,
    "difficulty": 0.2
  },
  {
    "patternId": "js.async.fetch.with.retry",
    "category": "async-await",
    "name": "Fetch带重试",
    "description": "Fetch请求失败时自动重试",
    "keywords": ["fetch", "retry", "async", "promise", "error"],
    "template": "async function fetchWithRetry({url}, {maxRetries} = 3) { for (let i = 0; i < maxRetries; i++) { try { const response = await fetch({url}); if (response.ok) return response; } catch (error) { if (i === maxRetries - 1) throw error; } } }",
    "example": "fetchWithRetry('/api/data', 3)",
    "score": 0.96,
    "language": "javascript",
    "popularity": 0.90,
    "difficulty": 0.4
  },
  {
    "patternId": "js.async.parallel",
    "category": "async-await",
    "name": "并行执行Promise",
    "description": "同时执行多个异步任务",
    "keywords": ["Promise", "parallel", "concurrent", "async", "all"],
    "template": "await Promise.all([{promises}])",
    "example": "await Promise.all([fetch(url1), fetch(url2)])",
    "score": 0.97,
    "language": "javascript",
    "popularity": 0.92,
    "difficulty": 0.3
  },
  {
    "patternId": "js.async.serial",
    "category": "async-await",
    "name": "串行执行Promise",
    "description": "顺序执行多个异步任务",
    "keywords": ["serial", "sequential", "async", "chain", "await"],
    "template": "for (const task of {tasks}) { await task(); }",
    "example": "for (const url of urls) { await fetch(url); }",
    "score": 0.95,
    "language": "javascript",
    "popularity": 0.88,
    "difficulty": 0.25
  },
  {
    "patternId": "js.async.race",
    "category": "async-await",
    "name": "竞速Promise",
    "description": "多个Promise中返回最快完成的",
    "keywords": ["race", "race", "async", "timeout", "first"],
    "template": "await Promise.race([{promise}, timeout])",
    "example": "await Promise.race([fetch(url), timeout(5000)])",
    "score": 0.94,
    "language": "javascript",
    "popularity": 0.85,
    "difficulty": 0.35
  },
  {
    "patternId": "js.async.delay",
    "category": "async-await",
    "name": "异步延迟",
    "description": "延迟指定时间再执行",
    "keywords": ["delay", "sleep", "timeout", "async", "wait"],
    "template": "await new Promise(resolve => setTimeout(resolve, {ms}))",
    "example": "await new Promise(r => setTimeout(r, 1000))",
    "score": 0.96,
    "language": "javascript",
    "popularity": 0.86,
    "difficulty": 0.15
  },
  {
    "patternId": "js.async.debounce",
    "category": "async-await",
    "name": "防抖",
    "description": "函数在一定时间后执行",
    "keywords": ["debounce", "delay", "throttle", "async", "timeout"],
    "template": "let timer; return async () => { clearTimeout(timer); timer = setTimeout(async () => await {action}(), {ms}); }",
    "example": "const debouncedFetch = debounce(async () => await fetch('/api'), 500)",
    "score": 0.92,
    "language": "javascript",
    "popularity": 0.84,
    "difficulty": 0.4
  },
  {
    "patternId": "js.async.throttle",
    "category": "async-await",
    "name": "节流",
    "description": "函数在指定时间间隔内只执行一次",
    "keywords": ["throttle", "rate", "limit", "async", "delay"],
    "template": "let lastRun = 0; return async () => { const now = Date.now(); if (now - lastRun >= {ms}) { lastRun = now; await {action}(); } }",
    "example": "const throttledFetch = throttle(async () => await fetch('/api'), 1000)",
    "score": 0.91,
    "language": "javascript",
    "popularity": 0.83,
    "difficulty": 0.45
  },
  {
    "patternId": "js.async.map",
    "category": "async-await",
    "name": "异步映射",
    "description": "对数组中的每个元素执行异步操作",
    "keywords": ["map", "async", "promise", "array", "transform"],
    "template": "await Promise.all(array.map(item => {action}(item)))",
    "example": "await Promise.all(items.map(async item => await process(item)))",
    "score": 0.96,
    "language": "javascript",
    "popularity": 0.91,
    "difficulty": 0.3
  },
  {
    "patternId": "js.async.filter",
    "category": "async-await",
    "name": "异步过滤",
    "description": "过滤满足条件的元素",
    "keywords": ["filter", "async", "promise", "array", "select"],
    "template": "const filtered = await Promise.all(array.filter(item => {condition}(item)).map(item => {action}(item)))",
    "example": "const results = await Promise.all(items.filter(item => item.active).map(item => fetch(item.url)))",
    "score": 0.94,
    "language": "javascript",
    "popularity": 0.87,
    "difficulty": 0.35
  },
  {
    "patternId": "js.async.retry",
    "category": "async-await",
    "name": "Promise重试",
    "description": "Promise失败时自动重试",
    "keywords": ["retry", "async", "promise", "error", "recovery"],
    "template": "async function retryPromise({fn}, {maxRetries}) { for (let i = 0; i < maxRetries; i++) { try { return await fn(); } catch (error) { if (i === maxRetries - 1) throw error; } } }",
    "example": "await retryPromise(() => fetch(url), 3)",
    "score": 0.95,
    "language": "javascript",
    "popularity": 0.89,
    "difficulty": 0.4
  },
  {
    "patternId": "js.async.timeout",
    "category": "async-await",
    "name": "Promise超时",
    "description": "设置Promise的超时时间",
    "keywords": ["timeout", "async", "promise", "deadline", "cancel"],
    "template": "Promise.race([{promise}, new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), {ms}))])",
    "example": "Promise.race([fetch(url), timeout(5000)])",
    "score": 0.94,
    "language": "javascript",
    "popularity": 0.86,
    "difficulty": 0.35
  },
  {
    "patternId": "js.async.error.retry",
    "category": "async-await",
    "name": "按错误类型重试",
    "description": "根据错误类型决定是否重试",
    "keywords": ["error", "retry", "type", "async", "condition"],
    "template": "async function retryIfError({fn}, {errorsToRetry}, {maxRetries}) { for (let i = 0; i < maxRetries; i++) { try { return await fn(); } catch (error) { if (!errorsToRetry.includes(error.code) || i === maxRetries - 1) throw error; } } }",
    "example": "await retryIfError(() => fetch(url), ['ECONNRESET', 'ETIMEDOUT'], 3)",
    "score": 0.93,
    "language": "javascript",
    "popularity": 0.84,
    "difficulty": 0.45
  },
  {
    "patternId": "js.async.fetch.with.abort",
    "category": "async-await",
    "name": "Fetch带中止",
    "description": "支持中止的Fetch请求",
    "keywords": ["fetch", "abort", "cancel", "async", "signal"],
    "template": "const controller = new AbortController(); const signal = controller.signal; fetch(url, {signal}).finally(() => controller.abort())",
    "example": "const {controller, promise} = createAbortableFetch(url)",
    "score": 0.90,
    "language": "javascript",
    "popularity": 0.82,
    "difficulty": 0.5
  },
  {
    "patternId": "js.async.sequential.map",
    "category": "async-await",
    "name": "串行映射",
    "description": "顺序执行数组中的异步任务",
    "keywords": ["sequential", "map", "async", "array", "transform"],
    "template": "for (const item of array) { const result = await action(item); results.push(result); }",
    "example": "for (const item of items) { const result = await process(item); results.push(result); }",
    "score": 0.93,
    "language": "javascript",
    "popularity": 0.85,
    "difficulty": 0.3
  },
  {
    "patternId": "js.async.retry.exponential",
    "category": "async-await",
    "name": "指数退避重试",
    "description": "每次重试间隔时间指数增长",
    "keywords": ["retry", "exponential", "backoff", "async", "delay"],
    "template": "let delay = 100; for (let i = 0; i < maxRetries; i++) { try { return await fn(); } catch (error) { if (i === maxRetries - 1) throw error; delay *= 2; await new Promise(r => setTimeout(r, delay)); } }",
    "example": "await retryExponential(() => fetch(url), 5)",
    "score": 0.94,
    "language": "javascript",
    "popularity": 0.87,
    "difficulty": 0.5
  },
  {
    "patternId": "js.async.retry.exponential.backoff",
    "category": "async-await",
    "name": "指数退避重试带最大间隔",
    "description": "指数退避重试，但不超过最大间隔时间",
    "keywords": ["retry", "exponential", "backoff", "max", "delay"],
    "template": "let delay = 100; for (let i = 0; i < maxRetries; i++) { try { return await fn(); } catch (error) { if (i === maxRetries - 1) throw error; delay = Math.min(delay * 2, {maxDelay}); await new Promise(r => setTimeout(r, delay)); } }",
    "example": "await retryExponentialBackoff(() => fetch(url), 5, 5000)",
    "score": 0.93,
    "language": "javascript",
    "popularity": 0.85,
    "difficulty": 0.5
  },
  {
    "patternId": "js.async.parallel.group",
    "category": "async-await",
    "name": "分组并行执行",
    "description": "将任务分组后并行执行每组",
    "keywords": ["parallel", "group", "batch", "async", "concurrent"],
    "template": "const batches = batchArray(array, batchSize); await Promise.all(batches.map(batch => Promise.all(batch.map(item => action(item)))))",
    "example": "const results = await parallelGroups(items, 10, async item => await process(item))",
    "score": 0.92,
    "language": "javascript",
    "popularity": 0.83,
    "difficulty": 0.45
  },
  {
    "patternId": "js.async.retry.limit",
    "category": "async-await",
    "name": "限制重试次数",
    "description": "同时限制并发数和重试次数",
    "keywords": ["retry", "limit", "concurrent", "async", "batch"],
    "template": "const results = []; for (const item of items) { let retries = 0; while (retries < maxRetries) { try { const result = await action(item); results.push(result); break; } catch (error) { retries++; if (retries === maxRetries) results.push(error); } } }",
    "example": "const results = await retryLimit(items, 3, async item => await fetch(item))",
    "score": 0.91,
    "language": "javascript",
    "popularity": 0.84,
    "difficulty": 0.5
  }
]
