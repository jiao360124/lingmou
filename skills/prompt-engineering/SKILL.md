# Prompt-Engineering - 提示工程专家

## 简介
Prompt-Engineering是我的提示工程专家，专注于优化和构建高质量的提示词，提升与大模型交互的效果。掌握各种提示技巧、框架和最佳实践。

## 核心目标

### 为什么需要提示工程？
- **提升回答质量** - 更准确、更相关、更有用
- **减少误解** - 明确的指令避免歧义
- **提高效率** - 更少尝试次数得到想要结果
- **扩展能力** - 充分发挥大模型潜力

## 提示技巧

### 1. 清晰明确
```
✅ 好的提示：
"请分析这个React组件的性能问题，并提供优化建议"

❌ 不好的提示：
"分析一下这个代码"
```

**关键要素**：
- 明确的任务描述
- 具体的输出格式
- 期望的质量标准

### 2. 提供上下文
```
✅ 好的提示：
"这是一段用于Next.js的API路由代码，用户需要一个登录接口。
请分析并提供安全最佳实践建议。"

❌ 不好的提示：
"分析这个API路由"
```

**上下文包含**：
- 任务背景
- 技术栈信息
- 业务需求
- 约束条件

### 3. 分步指示
```
✅ 好的提示：
"请帮我重构这段代码，步骤如下：
1. 分析当前代码结构
2. 识别可优化的部分
3. 提出具体的重构方案
4. 解释每个优化的好处"

❌ 不好的提示：
"重构这段代码"
```

**分步技巧**：
- 将复杂任务拆解
- 明确每个步骤的输出
- 设定执行顺序

### 4. 使用角色设定
```
✅ 好的提示：
"你是一名资深前端工程师，有10年React开发经验。
请评估这个组件的设计，并提供改进建议。"

❌ 不好的提示：
"评估这个组件"
```

**角色设定效果**：
- 激发专业思维
- 提供行业视角
- 增加回答深度

### 5. 限制条件
```
✅ 好的提示：
"请提供一个简短的代码示例（不超过50行），
展示如何使用TypeScript的泛型。"

❌ 不好的提示：
"给我一个TypeScript泛型的示例"
```

**限制条件类型**：
- 长度限制
- 格式限制
- 语言限制
- 时间限制

### 6. 示例驱动
```
✅ 好的提示：
"以下是我期望的输出格式示例：
输入：'如何连接数据库'
输出：'### 数据库连接

1. 安装驱动
2. 配置连接字符串
3. 编写连接代码'

请按照这种格式回答用户问题。"

❌ 不好的提示：
"回答用户问题"
```

**示例效果**：
- 明确输出风格
- 快速理解期望
- 减少猜测成本

### 7. 负面提示
```
✅ 好的提示：
"请分析这段代码，但不要修改代码本身，
只提供分析报告和改进建议。"

❌ 不好的提示：
"分析这段代码"
```

**负面提示用途**：
- 避免常见错误
- 控制输出范围
- 提高回答质量

## 提示框架

### 1. CO-STAR框架
```
Context (背景): 背景信息
Objective (目标): 具体任务
Style (风格): 回答风格
Tone (语气): 语气设定
Audience (受众): 面向对象
Response (响应): 输出格式
```

**示例**：
```
Context: 我正在学习React Hooks
Objective: 解释useEffect的工作原理
Style: 教学风格
Tone: 友好耐心
Audience: 初学者
Response: 使用代码示例和逐步解释
```

### 2. WRITE框架
```
Who (谁): 指定角色
Role (角色): 角色定位
Interest (兴趣): 兴趣点
Task (任务): 具体任务
Expectation (期望): 期望输出
```

**示例**：
```
Who: Python开发者
Role: 数据分析师
Interest: 数据处理和可视化
Task: 分析用户行为数据
Expectation: 生成统计报告和图表
```

### 3. LESS框架
```
L (Limit): 限制长度
E (Example): 提供示例
S (Style): 指定风格
S (Steps): 分步说明
```

### 4. ACT框架
```
A (Ask): 清晰提问
C (Context): 提供上下文
T (Type): 指定输出类型
```

### 5. MECE框架
```
Mutually Exclusive (相互独立)
Collectively Exhaustive (完全穷尽)
```

**应用**：
```
"请分析这个API的性能，从以下角度：
1. 响应时间
2. 资源使用
3. 并发能力
4. 错误处理
（确保每个角度相互独立且覆盖全面）"
```

## 常用提示模板

### 代码生成
```
作为[角色]，请[任务]，遵循以下规则：
1. [规则1]
2. [规则2]
3. [规则3]

使用[语言/框架]
输出[格式/限制]
```

### 代码审查
```
请审查这段[语言]代码：
[代码]

关注以下方面：
1. 代码质量和风格
2. 性能优化建议
3. 安全性问题
4. 可维护性

请提供：
- 具体的问题点
- 改进建议
- 代码示例
```

### 问题解决
```
问题描述：[问题描述]

背景信息：
- [背景1]
- [背景2]
- [背景3]

约束条件：
- [约束1]
- [约束2]

请按照以下步骤解决：
1. [步骤1]
2. [步骤2]
3. [步骤3]

并解释每个步骤的理由。
```

### 解释说明
```
请解释[概念/术语]，面向[目标受众]，
使用以下方法：
1. [方法1]
2. [方法2]

包含：
- 基本定义
- 具体示例
- 常见误区
- 最佳实践
```

### 技术建议
```
作为[角色]，针对[场景]，
请提供技术方案建议：

场景：
[场景描述]

要求：
1. [要求1]
2. [要求2]
3. [要求3]

提供：
- 技术方案
- 实现步骤
- 优缺点分析
- 替代方案
```

## 高级技巧

### 1. 思维链提示
```
请逐步思考并回答这个问题：

问题：[问题]

思考过程：
1. 首先理解问题的核心
2. 分析相关的因素
3. 考虑各种可能性
4. 排除不合适的选项
5. 形成最终答案

最终答案：[答案]
```

### 2. 对比分析
```
请对比以下方案：

方案A：
- [描述]
- [优点]
- [缺点]

方案B：
- [描述]
- [优点]
- [缺点]

使用以下标准评估：
1. [标准1]
2. [标准2]
3. [标准3]

提供最终建议。
```

### 3. 迭代优化
```
这是我的初始提示：

[初始提示]

请帮我优化这个提示，使其：
1. 更清晰明确
2. 更有针对性
3. 更易于理解

优化后的提示：
[优化提示]
```

### 4. 自我纠错
```
请分析这个回答：

[回答]

识别并修正以下问题：
1. 事实错误
2. 逻辑漏洞
3. 表达不清晰
4. 缺少必要信息

修正后的回答：
[修正回答]
```

## 常见陷阱

### 1. 过于模糊
```
❌ "帮我写代码"
✅ "用Python写一个函数，从CSV文件读取数据并计算平均值"
```

### 2. 缺少上下文
```
❌ "分析这段代码"
✅ "分析这段React组件的性能问题，用户反馈加载缓慢"
```

### 3. 过度依赖
```
❌ "帮我做所有事情"
✅ "帮我做这三件事，优先级如下..."
```

### 4. 格式混乱
```
❌ 不分层次的信息堆砌
✅ 使用标题、列表、代码块等结构化格式
```

### 5. 忽视反馈
```
❌ 一次尝试就放弃
✅ 根据反馈迭代优化提示
```

## 提示评估标准

### 有效性
- 是否能得到期望的输出？
- 是否避免了常见错误？
- 是否节省了交互时间？

### 清晰性
- 是否易于理解？
- 是否有歧义？
- 是否提供了足够细节？

### 完整性
- 是否包含了所有必要信息？
- 是否考虑了边界情况？
- 是否提供了充分的上下文？

### 针对性
- 是否针对特定任务？
- 是否适合目标受众？
- 是否考虑了约束条件？

## 实践建议

### 1. 从简单开始
- 先尝试基本提示
- 逐步增加复杂度
- 记录哪些提示有效

### 2. 记录和复用
- 保存成功的提示模板
- 记录提示和结果的对应关系
- 建立个人提示库

### 3. 持续优化
- 根据结果调整提示
- 尝试不同的提示风格
- 学习新的提示技巧

### 4. 上下文很重要
- 提供足够的背景信息
- 明确任务的范围和目标
- 说明期望的输出格式

## 工具和资源

### 常用资源
- OpenAI Prompt Library
- Anthropic Prompt Engineering Guide
- LangChain Prompt Template Guide
- 各大AI平台官方文档

### 提示优化工具
- 提示模板生成器
- 提示质量检查器
- 上下文分析工具

## 版本历史
- v1.0.0 (2026-02-12) - 初始版本，提供基础提示工程技巧和框架
